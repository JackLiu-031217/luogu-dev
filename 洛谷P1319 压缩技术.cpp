//洛谷OJ P1319 压缩技术
//设某汉字由N × N的0和1的点阵图案组成。
//我们依照以下规则生成压缩码。连续一组数值：
//从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。
//第一个数表示连续有几个0，第二个数表示接下来连续有几个1，
//第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……
//例如: 以下汉字点阵图案：
//          0001000
//          0001000
//          0001111
//          0001000
//          0001000
//          0001000
//          1111111
//对应的压缩码是: 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 (第一个数是N,其余各位表示交替表示0和1的个数,压缩码保证 N * N = 交替的各位数之和)
//https://www.luogu.com.cn/record/39209164
#include<iostream>
using namespace std;
int main(){
    int n,x,p=0;
    bool z=true,sq[40000]={false};
    cin>>n;
    while(p<(n*n)){ //判断输入是否到头,此种判断方法貌似只能用scanf,cin貌似会无法转换
        if(z){
            cin>>x; //使用布尔变量z标记数字是0还是1
            for(int i=1+p;i<=p+x;i++){
                sq[i]=0;
            }
            p+=x; //使用变量记录数加到了矩阵的哪个方位
            z=!z; //两 极 反 转
        }else if(z!=true){
            cin>>x;
            for(int i=1+p;i<=p+x;i++){
                sq[i]=1;
            }
            p+=x;
            z=!z;
        }
    }
    for(int i=1;i<=p;i++){
        cout<<sq[i];
        if(i%n==0){
            cout<<endl;
        }
    }
    return 0;
}